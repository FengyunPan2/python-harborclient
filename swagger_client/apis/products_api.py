# coding: utf-8

"""
    Harbor API

    These APIs provide services for manipulating Harbor project.

    OpenAPI spec version: 0.3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ProductsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def configurations_get(self, **kwargs):
        """
        Get system configurations.
        This endpoint is for retrieving system configurations that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Configurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.configurations_get_with_http_info(**kwargs)
        else:
            (data) = self.configurations_get_with_http_info(**kwargs)
            return data

    def configurations_get_with_http_info(self, **kwargs):
        """
        Get system configurations.
        This endpoint is for retrieving system configurations that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Configurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/configurations', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Configurations',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def configurations_put(self, configurations, **kwargs):
        """
        Modify system configurations.
        This endpoint is for modifying system configurations that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_put(configurations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.configurations_put_with_http_info(configurations, **kwargs)
        else:
            (data) = self.configurations_put_with_http_info(configurations, **kwargs)
            return data

    def configurations_put_with_http_info(self, configurations, **kwargs):
        """
        Modify system configurations.
        This endpoint is for modifying system configurations that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_put_with_http_info(configurations, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Configurations configurations: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['configurations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'configurations' is set
        if ('configurations' not in params) or (params['configurations'] is None):
            raise ValueError("Missing the required parameter `configurations` when calling `configurations_put`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'configurations' in params:
            body_params = params['configurations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/configurations', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def configurations_reset_post(self, **kwargs):
        """
        Reset system configurations.
        Reset system configurations from environment variables. Can only be accessed by admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_reset_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.configurations_reset_post_with_http_info(**kwargs)
        else:
            (data) = self.configurations_reset_post_with_http_info(**kwargs)
            return data

    def configurations_reset_post_with_http_info(self, **kwargs):
        """
        Reset system configurations.
        Reset system configurations from environment variables. Can only be accessed by admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.configurations_reset_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_reset_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/configurations/reset', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def email_ping_post(self, **kwargs):
        """
        Test connection and authentication with email server.
        Test connection and authentication with email server.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.email_ping_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param EmailServerSetting settings: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.email_ping_post_with_http_info(**kwargs)
        else:
            (data) = self.email_ping_post_with_http_info(**kwargs)
            return data

    def email_ping_post_with_http_info(self, **kwargs):
        """
        Test connection and authentication with email server.
        Test connection and authentication with email server.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.email_ping_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param EmailServerSetting settings: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['settings']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_ping_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'settings' in params:
            body_params = params['settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/email/ping', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def internal_syncregistry_post(self, **kwargs):
        """
        Sync repositories from registry to DB.
        This endpoint is for syncing all repositories of registry with database.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.internal_syncregistry_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.internal_syncregistry_post_with_http_info(**kwargs)
        else:
            (data) = self.internal_syncregistry_post_with_http_info(**kwargs)
            return data

    def internal_syncregistry_post_with_http_info(self, **kwargs):
        """
        Sync repositories from registry to DB.
        This endpoint is for syncing all repositories of registry with database.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.internal_syncregistry_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_syncregistry_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/internal/syncregistry', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def jobs_replication_get(self, policy_id, **kwargs):
        """
        List filters jobs according to the policy and repository
        This endpoint let user list filters jobs according to the policy and repository. (if start_time and end_time are both null, list jobs of last 10 days) 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_get(policy_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int policy_id: The ID of the policy that triggered this job. (required)
        :param int num: The return list length number.
        :param int end_time: The end time of jobs done. (Timestamp)
        :param int start_time: The start time of jobs. (Timestamp)
        :param str repository: The respond jobs list filter by repository name.
        :param str status: The respond jobs list filter by status.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[JobStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.jobs_replication_get_with_http_info(policy_id, **kwargs)
        else:
            (data) = self.jobs_replication_get_with_http_info(policy_id, **kwargs)
            return data

    def jobs_replication_get_with_http_info(self, policy_id, **kwargs):
        """
        List filters jobs according to the policy and repository
        This endpoint let user list filters jobs according to the policy and repository. (if start_time and end_time are both null, list jobs of last 10 days) 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_get_with_http_info(policy_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int policy_id: The ID of the policy that triggered this job. (required)
        :param int num: The return list length number.
        :param int end_time: The end time of jobs done. (Timestamp)
        :param int start_time: The start time of jobs. (Timestamp)
        :param str repository: The respond jobs list filter by repository name.
        :param str status: The respond jobs list filter by status.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[JobStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policy_id', 'num', 'end_time', 'start_time', 'repository', 'status', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params) or (params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `jobs_replication_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'policy_id' in params:
            query_params.append(('policy_id', params['policy_id']))
        if 'num' in params:
            query_params.append(('num', params['num']))
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))
        if 'repository' in params:
            query_params.append(('repository', params['repository']))
        if 'status' in params:
            query_params.append(('status', params['status']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/jobs/replication', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[JobStatus]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def jobs_replication_id_delete(self, id, **kwargs):
        """
        Delete specific ID job.
        This endpoint is aimed to remove specific ID job from jobservice. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Delete job ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.jobs_replication_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.jobs_replication_id_delete_with_http_info(id, **kwargs)
            return data

    def jobs_replication_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete specific ID job.
        This endpoint is aimed to remove specific ID job from jobservice. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Delete job ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_replication_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/jobs/replication/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def jobs_replication_id_log_get(self, id, **kwargs):
        """
        Get job logs.
        This endpoint let user search job logs filtered by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_id_log_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.jobs_replication_id_log_get_with_http_info(id, **kwargs)
        else:
            (data) = self.jobs_replication_id_log_get_with_http_info(id, **kwargs)
            return data

    def jobs_replication_id_log_get_with_http_info(self, id, **kwargs):
        """
        Get job logs.
        This endpoint let user search job logs filtered by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_replication_id_log_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_replication_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_replication_id_log_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/jobs/replication/{id}/log', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def jobs_scan_id_log_get(self, id, **kwargs):
        """
        Get job logs.
        This endpoint let user get scan job logs filtered by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_scan_id_log_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.jobs_scan_id_log_get_with_http_info(id, **kwargs)
        else:
            (data) = self.jobs_scan_id_log_get_with_http_info(id, **kwargs)
            return data

    def jobs_scan_id_log_get_with_http_info(self, id, **kwargs):
        """
        Get job logs.
        This endpoint let user get scan job logs filtered by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.jobs_scan_id_log_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: Relevant job ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_scan_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `jobs_scan_id_log_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/jobs/scan/{id}/log', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_ping_post(self, **kwargs):
        """
        Ping available ldap service.
        This endpoint ping the available ldap service for test related configuration parameters.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_ping_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_ping_post_with_http_info(**kwargs)
        else:
            (data) = self.ldap_ping_post_with_http_info(**kwargs)
            return data

    def ldap_ping_post_with_http_info(self, **kwargs):
        """
        Ping available ldap service.
        This endpoint ping the available ldap service for test related configuration parameters.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_ping_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LdapConf ldapconf: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapconf']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_ping_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ldapconf' in params:
            body_params = params['ldapconf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/ldap/ping', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_users_import_post(self, uid_list, **kwargs):
        """
        Import selected available ldap users.
        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information.  If have errors when import user, will return the list of importing failed uid and the failed reason. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_users_import_post(uid_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_users_import_post_with_http_info(uid_list, **kwargs)
        else:
            (data) = self.ldap_users_import_post_with_http_info(uid_list, **kwargs)
            return data

    def ldap_users_import_post_with_http_info(self, uid_list, **kwargs):
        """
        Import selected available ldap users.
        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information.  If have errors when import user, will return the list of importing failed uid and the failed reason. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_users_import_post_with_http_info(uid_list, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param LdapImportUsers uid_list: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uid_list']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_import_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uid_list' is set
        if ('uid_list' not in params) or (params['uid_list'] is None):
            raise ValueError("Missing the required parameter `uid_list` when calling `ldap_users_import_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uid_list' in params:
            body_params = params['uid_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/ldap/users/import', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_users_search_post(self, **kwargs):
        """
        Search available ldap users.
        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_users_search_post(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Registered user ID
        :param LdapConf ldap_conf: ldap search configuration. ldapconf field can input ldap service configuration. If this item are blank, will load default configuration will load current configuration from the system.
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_users_search_post_with_http_info(**kwargs)
        else:
            (data) = self.ldap_users_search_post_with_http_info(**kwargs)
            return data

    def ldap_users_search_post_with_http_info(self, **kwargs):
        """
        Search available ldap users.
        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_users_search_post_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Registered user ID
        :param LdapConf ldap_conf: ldap search configuration. ldapconf field can input ldap service configuration. If this item are blank, will load default configuration will load current configuration from the system.
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'ldap_conf']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_search_post" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ldap_conf' in params:
            body_params = params['ldap_conf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/ldap/users/search', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[LdapUsers]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def logs_get(self, **kwargs):
        """
        Get recent logs of the projects which the user is a member of
        This endpoint let user see the recent operation logs of the projects which he is member of  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.logs_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.logs_get_with_http_info(**kwargs)
        else:
            (data) = self.logs_get_with_http_info(**kwargs)
            return data

    def logs_get_with_http_info(self, **kwargs):
        """
        Get recent logs of the projects which the user is a member of
        This endpoint let user see the recent operation logs of the projects which he is member of  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.logs_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))
        if 'repository' in params:
            query_params.append(('repository', params['repository']))
        if 'tag' in params:
            query_params.append(('tag', params['tag']))
        if 'operation' in params:
            query_params.append(('operation', params['operation']))
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/logs', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AccessLog]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def policies_replication_get(self, **kwargs):
        """
        List filters policies by name and project_id
        This endpoint let user list filters policies by name and project_id, if name and project_id are nil, list returns all policies 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The replication's policy name.
        :param int project_id: Relevant project ID.
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.policies_replication_get_with_http_info(**kwargs)
        else:
            (data) = self.policies_replication_get_with_http_info(**kwargs)
            return data

    def policies_replication_get_with_http_info(self, **kwargs):
        """
        List filters policies by name and project_id
        This endpoint let user list filters policies by name and project_id, if name and project_id are nil, list returns all policies 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The replication's policy name.
        :param int project_id: Relevant project ID.
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/policies/replication', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[RepPolicy]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def policies_replication_id_enablement_put(self, id, enabledflag, **kwargs):
        """
        Put modifies enablement of the policy.
        This endpoint let user update policy enablement flag. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_enablement_put(id, enabledflag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :param RepPolicyEnablementReq enabledflag: The policy enablement flag. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.policies_replication_id_enablement_put_with_http_info(id, enabledflag, **kwargs)
        else:
            (data) = self.policies_replication_id_enablement_put_with_http_info(id, enabledflag, **kwargs)
            return data

    def policies_replication_id_enablement_put_with_http_info(self, id, enabledflag, **kwargs):
        """
        Put modifies enablement of the policy.
        This endpoint let user update policy enablement flag. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_enablement_put_with_http_info(id, enabledflag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :param RepPolicyEnablementReq enabledflag: The policy enablement flag. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'enabledflag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_id_enablement_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `policies_replication_id_enablement_put`")
        # verify the required parameter 'enabledflag' is set
        if ('enabledflag' not in params) or (params['enabledflag'] is None):
            raise ValueError("Missing the required parameter `enabledflag` when calling `policies_replication_id_enablement_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enabledflag' in params:
            body_params = params['enabledflag']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/policies/replication/{id}/enablement', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def policies_replication_id_get(self, id, **kwargs):
        """
        Get replication policy.
        This endpoint let user search replication policy by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :return: RepPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.policies_replication_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.policies_replication_id_get_with_http_info(id, **kwargs)
            return data

    def policies_replication_id_get_with_http_info(self, id, **kwargs):
        """
        Get replication policy.
        This endpoint let user search replication policy by specific ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :return: RepPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `policies_replication_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/policies/replication/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RepPolicy',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def policies_replication_id_put(self, id, policyupdate, **kwargs):
        """
        Put modifies name, description, target and enablement of policy.
        This endpoint let user update policy name, description, target and enablement. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_put(id, policyupdate, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :param RepPolicyUpdate policyupdate: Update policy name, description, target and enablement. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.policies_replication_id_put_with_http_info(id, policyupdate, **kwargs)
        else:
            (data) = self.policies_replication_id_put_with_http_info(id, policyupdate, **kwargs)
            return data

    def policies_replication_id_put_with_http_info(self, id, policyupdate, **kwargs):
        """
        Put modifies name, description, target and enablement of policy.
        This endpoint let user update policy name, description, target and enablement. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_id_put_with_http_info(id, policyupdate, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: policy ID (required)
        :param RepPolicyUpdate policyupdate: Update policy name, description, target and enablement. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'policyupdate']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `policies_replication_id_put`")
        # verify the required parameter 'policyupdate' is set
        if ('policyupdate' not in params) or (params['policyupdate'] is None):
            raise ValueError("Missing the required parameter `policyupdate` when calling `policies_replication_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policyupdate' in params:
            body_params = params['policyupdate']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/policies/replication/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def policies_replication_post(self, policyinfo, **kwargs):
        """
        Post creates a policy
        This endpoint let user creates a policy, and if it is enabled, the replication will be triggered right now. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_post(policyinfo, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RepPolicyPost policyinfo: Create new policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.policies_replication_post_with_http_info(policyinfo, **kwargs)
        else:
            (data) = self.policies_replication_post_with_http_info(policyinfo, **kwargs)
            return data

    def policies_replication_post_with_http_info(self, policyinfo, **kwargs):
        """
        Post creates a policy
        This endpoint let user creates a policy, and if it is enabled, the replication will be triggered right now. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.policies_replication_post_with_http_info(policyinfo, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RepPolicyPost policyinfo: Create new policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policyinfo']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method policies_replication_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'policyinfo' is set
        if ('policyinfo' not in params) or (params['policyinfo'] is None):
            raise ValueError("Missing the required parameter `policyinfo` when calling `policies_replication_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policyinfo' in params:
            body_params = params['policyinfo']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/policies/replication', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_get(self, **kwargs):
        """
        List projects
        This endpoint returns all projects created by Harbor, and can be filtered by project name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_get_with_http_info(**kwargs)
        else:
            (data) = self.projects_get_with_http_info(**kwargs)
            return data

    def projects_get_with_http_info(self, **kwargs):
        """
        List projects
        This endpoint returns all projects created by Harbor, and can be filtered by project name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'public', 'owner', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))
        if 'public' in params:
            query_params.append(('public', params['public']))
        if 'owner' in params:
            query_params.append(('owner', params['owner']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Project]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_head(self, project_name, **kwargs):
        """
        Check if the project name user provided already exists.
        This endpoint is used to check if the project name user provided already exist. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_head(project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_head_with_http_info(project_name, **kwargs)
        else:
            (data) = self.projects_head_with_http_info(project_name, **kwargs)
            return data

    def projects_head_with_http_info(self, project_name, **kwargs):
        """
        Check if the project name user provided already exists.
        This endpoint is used to check if the project name user provided already exist. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_head_with_http_info(project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_head" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `projects_head`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_name' in params:
            query_params.append(('project_name', params['project_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects', 'HEAD',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_post(self, project, **kwargs):
        """
        Create a new project.
        This endpoint is for user to create a new project. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_post(project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ProjectReq project: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_post_with_http_info(project, **kwargs)
        else:
            (data) = self.projects_post_with_http_info(project, **kwargs)
            return data

    def projects_post_with_http_info(self, project, **kwargs):
        """
        Create a new project.
        This endpoint is for user to create a new project. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_post_with_http_info(project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ProjectReq project: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project' in params:
            body_params = params['project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_delete(self, project_id, **kwargs):
        """
        Delete project by projectID
        This endpoint is aimed to delete project by project ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_delete(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_delete_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_delete_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_delete_with_http_info(self, project_id, **kwargs):
        """
        Delete project by projectID
        This endpoint is aimed to delete project by project ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_delete_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_get(self, project_id, **kwargs):
        """
        Return specific project detail infomation
        This endpoint returns specific project information by project ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_get(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_get_with_http_info(self, project_id, **kwargs):
        """
        Return specific project detail infomation
        This endpoint returns specific project information by project ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_get_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Project',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_logs_get(self, project_id, **kwargs):
        """
        Get access logs accompany with a relevant project.
        This endpoint let user search access logs filtered by operations and date time ranges. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_logs_get(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_logs_get_with_http_info(self, project_id, **kwargs):
        """
        Get access logs accompany with a relevant project.
        This endpoint let user search access logs filtered by operations and date time ranges. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_logs_get_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_logs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_logs_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))
        if 'repository' in params:
            query_params.append(('repository', params['repository']))
        if 'tag' in params:
            query_params.append(('tag', params['tag']))
        if 'operation' in params:
            query_params.append(('operation', params['operation']))
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/logs', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[AccessLog]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_members_get(self, project_id, **kwargs):
        """
        Return a project's relevant role members.
        This endpoint is for user to search a specified project's relevant role members. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_get(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_members_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_members_get_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_members_get_with_http_info(self, project_id, **kwargs):
        """
        Return a project's relevant role members.
        This endpoint is for user to search a specified project's relevant role members. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_get_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/members/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[User]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_members_post(self, project_id, **kwargs):
        """
        Add project role member accompany with relevant project and user.
        This endpoint is for user to add project role member accompany with relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_post(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param RoleParam roles: Role members for adding to relevant project. Only one role is supported in the role list.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_members_post_with_http_info(project_id, **kwargs)
        else:
            (data) = self.projects_project_id_members_post_with_http_info(project_id, **kwargs)
            return data

    def projects_project_id_members_post_with_http_info(self, project_id, **kwargs):
        """
        Add project role member accompany with relevant project and user.
        This endpoint is for user to add project role member accompany with relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_post_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param RoleParam roles: Role members for adding to relevant project. Only one role is supported in the role list.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'roles']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_post`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'roles' in params:
            body_params = params['roles']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/members/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_members_user_id_delete(self, project_id, user_id, **kwargs):
        """
        Delete project role members accompany with relevant project and user.
        This endpoint is aimed to remove project role members already added to the relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_delete(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param int user_id: Relevant user ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_members_user_id_delete_with_http_info(project_id, user_id, **kwargs)
        else:
            (data) = self.projects_project_id_members_user_id_delete_with_http_info(project_id, user_id, **kwargs)
            return data

    def projects_project_id_members_user_id_delete_with_http_info(self, project_id, user_id, **kwargs):
        """
        Delete project role members accompany with relevant project and user.
        This endpoint is aimed to remove project role members already added to the relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_delete_with_http_info(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param int user_id: Relevant user ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'user_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_user_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_user_id_delete`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `projects_project_id_members_user_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/members/{user_id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_members_user_id_get(self, project_id, user_id, **kwargs):
        """
        Return role members accompany with relevant project and user.
        This endpoint is for user to get role members accompany with relevant project and user.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_get(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID (required)
        :param int user_id: Relevant user ID (required)
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_members_user_id_get_with_http_info(project_id, user_id, **kwargs)
        else:
            (data) = self.projects_project_id_members_user_id_get_with_http_info(project_id, user_id, **kwargs)
            return data

    def projects_project_id_members_user_id_get_with_http_info(self, project_id, user_id, **kwargs):
        """
        Return role members accompany with relevant project and user.
        This endpoint is for user to get role members accompany with relevant project and user.  
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_get_with_http_info(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID (required)
        :param int user_id: Relevant user ID (required)
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'user_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_user_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_user_id_get`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `projects_project_id_members_user_id_get`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/members/{user_id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Role]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_members_user_id_put(self, project_id, user_id, **kwargs):
        """
        Update project role members accompany with relevant project and user.
        This endpoint is for user to update current project role members accompany with relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_put(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param int user_id: Relevant user ID. (required)
        :param RoleParam roles: Updates for roles and username.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_members_user_id_put_with_http_info(project_id, user_id, **kwargs)
        else:
            (data) = self.projects_project_id_members_user_id_put_with_http_info(project_id, user_id, **kwargs)
            return data

    def projects_project_id_members_user_id_put_with_http_info(self, project_id, user_id, **kwargs):
        """
        Update project role members accompany with relevant project and user.
        This endpoint is for user to update current project role members accompany with relevant project and user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_members_user_id_put_with_http_info(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param int user_id: Relevant user ID. (required)
        :param RoleParam roles: Updates for roles and username.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'user_id', 'roles']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_user_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_user_id_put`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `projects_project_id_members_user_id_put`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'roles' in params:
            body_params = params['roles']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/members/{user_id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def projects_project_id_publicity_put(self, project_id, project, **kwargs):
        """
        Update properties for a selected project.
        This endpoint is aimed to toggle a project publicity status. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_publicity_put(project_id, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Selected project ID. (required)
        :param Project project: Updates of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.projects_project_id_publicity_put_with_http_info(project_id, project, **kwargs)
        else:
            (data) = self.projects_project_id_publicity_put_with_http_info(project_id, project, **kwargs)
            return data

    def projects_project_id_publicity_put_with_http_info(self, project_id, project, **kwargs):
        """
        Update properties for a selected project.
        This endpoint is aimed to toggle a project publicity status. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.projects_project_id_publicity_put_with_http_info(project_id, project, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Selected project ID. (required)
        :param Project project: Updates of project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_publicity_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_publicity_put`")
        # verify the required parameter 'project' is set
        if ('project' not in params) or (params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `projects_project_id_publicity_put`")


        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project' in params:
            body_params = params['project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/projects/{project_id}/publicity', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_get(self, project_id, **kwargs):
        """
        Get repositories accompany with relevant project and repo name.
        This endpoint let user search repositories accompanying with relevant project ID and repo name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_get(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_get_with_http_info(project_id, **kwargs)
        else:
            (data) = self.repositories_get_with_http_info(project_id, **kwargs)
            return data

    def repositories_get_with_http_info(self, project_id, **kwargs):
        """
        Get repositories accompany with relevant project and repo name.
        This endpoint let user search repositories accompanying with relevant project ID and repo name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_get_with_http_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'q', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `repositories_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))
        if 'q' in params:
            query_params.append(('q', params['q']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Repository]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_delete(self, repo_name, **kwargs):
        """
        Delete a repository.
        This endpoint let user delete a repository with name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_delete(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)
        else:
            (data) = self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)
            return data

    def repositories_repo_name_delete_with_http_info(self, repo_name, **kwargs):
        """
        Delete a repository.
        This endpoint let user delete a repository with name. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_delete_with_http_info(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_delete`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_signatures_get(self, repo_name, **kwargs):
        """
        Get signature information of a repository
        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_signatures_get(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)
        else:
            (data) = self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)
            return data

    def repositories_repo_name_signatures_get_with_http_info(self, repo_name, **kwargs):
        """
        Get signature information of a repository
        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_signatures_get_with_http_info(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_signatures_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_signatures_get`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/signatures', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[RepoSignature]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_get(self, repo_name, **kwargs):
        """
        Get tags of a relevant repository.
        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_get(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Relevant repository name. (required)
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)
            return data

    def repositories_repo_name_tags_get_with_http_info(self, repo_name, **kwargs):
        """
        Get tags of a relevant repository.
        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_get_with_http_info(repo_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Relevant repository name. (required)
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_get`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[DetailedTag]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_delete(self, repo_name, tag, **kwargs):
        """
        Delete a tag in a repository.
        This endpoint let user delete tags with repo name and tag. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_delete(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)
            return data

    def repositories_repo_name_tags_tag_delete_with_http_info(self, repo_name, tag, **kwargs):
        """
        Delete a tag in a repository.
        This endpoint let user delete tags with repo name and tag. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_delete`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_delete`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags/{tag}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_get(self, repo_name, tag, **kwargs):
        """
        Get the tag of the repository.
        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_get(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)
            return data

    def repositories_repo_name_tags_tag_get_with_http_info(self, repo_name, tag, **kwargs):
        """
        Get the tag of the repository.
        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_get`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_get`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags/{tag}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DetailedTag',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_manifest_get(self, repo_name, tag, **kwargs):
        """
        Get manifests of a relevant repository.
        This endpoint aims to retreive manifests from a relevant repository. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)
            return data

    def repositories_repo_name_tags_tag_manifest_get_with_http_info(self, repo_name, tag, **kwargs):
        """
        Get manifests of a relevant repository.
        This endpoint aims to retreive manifests from a relevant repository. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'version']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_manifest_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_manifest_get`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_manifest_get`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags/{tag}/manifest', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Manifest',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_scan_post(self, repo_name, tag, **kwargs):
        """
        Scan the image.
        Trigger jobservice to call Clair API to scan the image identified by the repo_name and tag.  Only project admins have permission to scan images under the project. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_scan_post(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)
            return data

    def repositories_repo_name_tags_tag_scan_post_with_http_info(self, repo_name, tag, **kwargs):
        """
        Scan the image.
        Trigger jobservice to call Clair API to scan the image identified by the repo_name and tag.  Only project admins have permission to scan images under the project. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_scan_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_scan_post`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_scan_post`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags/{tag}/scan', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_vulnerability_details_get(self, repo_name, tag, **kwargs):
        """
        Get vulnerability details of the image.
        Call Clair API to get the vulnerability based on the previous successful scan. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_vulnerability_details_get(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: list[DefinitionsVulnerabilityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, **kwargs)
        else:
            (data) = self.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, **kwargs)
            return data

    def repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(self, repo_name, tag, **kwargs):
        """
        Get vulnerability details of the image.
        Call Clair API to get the vulnerability based on the previous successful scan. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_repo_name_tags_tag_vulnerability_details_get_with_http_info(repo_name, tag, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: list[DefinitionsVulnerabilityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_vulnerability_details_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params) or (params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_vulnerability_details_get`")
        # verify the required parameter 'tag' is set
        if ('tag' not in params) or (params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_vulnerability_details_get`")


        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']
        if 'tag' in params:
            path_params['tag'] = params['tag']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/{repo_name}/tags/{tag}/vulnerability/details', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[DefinitionsVulnerabilityItem]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def repositories_top_get(self, **kwargs):
        """
        Get public repositories which are accessed most.
        This endpoint aims to let users see the most popular public repositories 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_top_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.repositories_top_get_with_http_info(**kwargs)
        else:
            (data) = self.repositories_top_get_with_http_info(**kwargs)
            return data

    def repositories_top_get_with_http_info(self, **kwargs):
        """
        Get public repositories which are accessed most.
        This endpoint aims to let users see the most popular public repositories 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.repositories_top_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['count']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_top_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/repositories/top', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Repository]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def search_get(self, q, **kwargs):
        """
        Search for projects and repositories
        The Search endpoint returns information about the projects and repositories offered at public status or related to the current logged in user. The response includes the project and repository list in a proper display order. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search_get(q, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.search_get_with_http_info(q, **kwargs)
        else:
            (data) = self.search_get_with_http_info(q, **kwargs)
            return data

    def search_get_with_http_info(self, q, **kwargs):
        """
        Search for projects and repositories
        The Search endpoint returns information about the projects and repositories offered at public status or related to the current logged in user. The response includes the project and repository list in a proper display order. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search_get_with_http_info(q, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in params) or (params['q'] is None):
            raise ValueError("Missing the required parameter `q` when calling `search_get`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/search', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Search]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def statistics_get(self, **kwargs):
        """
        Get projects number and repositories number relevant to the user
        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.statistics_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.statistics_get_with_http_info(**kwargs)
        else:
            (data) = self.statistics_get_with_http_info(**kwargs)
            return data

    def statistics_get_with_http_info(self, **kwargs):
        """
        Get projects number and repositories number relevant to the user
        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.statistics_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statistics_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/statistics', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StatisticMap',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def systeminfo_get(self, **kwargs):
        """
        Get general system info
        This API is for retrieving general system info, this can be called by anonymous request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.systeminfo_get_with_http_info(**kwargs)
        else:
            (data) = self.systeminfo_get_with_http_info(**kwargs)
            return data

    def systeminfo_get_with_http_info(self, **kwargs):
        """
        Get general system info
        This API is for retrieving general system info, this can be called by anonymous request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/systeminfo', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='object',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def systeminfo_getcert_get(self, **kwargs):
        """
        Get default root certificate under OVA deployment.
        This endpoint is for downloading a default root certificate that only provides for admin user under OVA deployment. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_getcert_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.systeminfo_getcert_get_with_http_info(**kwargs)
        else:
            (data) = self.systeminfo_getcert_get_with_http_info(**kwargs)
            return data

    def systeminfo_getcert_get_with_http_info(self, **kwargs):
        """
        Get default root certificate under OVA deployment.
        This endpoint is for downloading a default root certificate that only provides for admin user under OVA deployment. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_getcert_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_getcert_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/systeminfo/getcert', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def systeminfo_volumes_get(self, **kwargs):
        """
        Get system volume info (total/free size).
        This endpoint is for retrieving system volume info that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_volumes_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.systeminfo_volumes_get_with_http_info(**kwargs)
        else:
            (data) = self.systeminfo_volumes_get_with_http_info(**kwargs)
            return data

    def systeminfo_volumes_get_with_http_info(self, **kwargs):
        """
        Get system volume info (total/free size).
        This endpoint is for retrieving system volume info that only provides for admin user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.systeminfo_volumes_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_volumes_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/systeminfo/volumes', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='object',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_get(self, **kwargs):
        """
        List filters targets by name.
        This endpoint let user list filters targets by name, if name is nil, list returns all targets. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The replication's target name.
        :return: list[RepTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_get_with_http_info(**kwargs)
        else:
            (data) = self.targets_get_with_http_info(**kwargs)
            return data

    def targets_get_with_http_info(self, **kwargs):
        """
        List filters targets by name.
        This endpoint let user list filters targets by name, if name is nil, list returns all targets. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: The replication's target name.
        :return: list[RepTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[RepTarget]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_id_delete(self, id, **kwargs):
        """
        Delete specific replication's target.
        This endpoint is for to delete specific replication's target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_delete(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_id_delete_with_http_info(id, **kwargs)
        else:
            (data) = self.targets_id_delete_with_http_info(id, **kwargs)
            return data

    def targets_id_delete_with_http_info(self, id, **kwargs):
        """
        Delete specific replication's target.
        This endpoint is for to delete specific replication's target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_delete_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/{id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_id_get(self, id, **kwargs):
        """
        Get replication's target.
        This endpoint is for get specific replication's target.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: RepTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_id_get_with_http_info(id, **kwargs)
        else:
            (data) = self.targets_id_get_with_http_info(id, **kwargs)
            return data

    def targets_id_get_with_http_info(self, id, **kwargs):
        """
        Get replication's target.
        This endpoint is for get specific replication's target.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: RepTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RepTarget',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_id_ping_post(self, id, **kwargs):
        """
        Ping target.
        This endpoint is for ping target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_ping_post(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_id_ping_post_with_http_info(id, **kwargs)
        else:
            (data) = self.targets_id_ping_post_with_http_info(id, **kwargs)
            return data

    def targets_id_ping_post_with_http_info(self, id, **kwargs):
        """
        Ping target.
        This endpoint is for ping target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_ping_post_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_ping_post`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/{id}/ping', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_id_policies_get(self, id, **kwargs):
        """
        List the target relevant policies.
        This endpoint list policies filter with specific replication's target ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_policies_get(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_id_policies_get_with_http_info(id, **kwargs)
        else:
            (data) = self.targets_id_policies_get_with_http_info(id, **kwargs)
            return data

    def targets_id_policies_get_with_http_info(self, id, **kwargs):
        """
        List the target relevant policies.
        This endpoint list policies filter with specific replication's target ID. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_policies_get_with_http_info(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :return: list[RepPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_policies_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_policies_get`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/{id}/policies/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[RepPolicy]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_id_put(self, id, repo_target, **kwargs):
        """
        Update replication's target.
        This endpoint is for update specific replication's target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_put(id, repo_target, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :param PutTarget repo_target: Updates of replication's target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_id_put_with_http_info(id, repo_target, **kwargs)
        else:
            (data) = self.targets_id_put_with_http_info(id, repo_target, **kwargs)
            return data

    def targets_id_put_with_http_info(self, id, repo_target, **kwargs):
        """
        Update replication's target.
        This endpoint is for update specific replication's target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_id_put_with_http_info(id, repo_target, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int id: The replication's target ID. (required)
        :param PutTarget repo_target: Updates of replication's target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'repo_target']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `targets_id_put`")
        # verify the required parameter 'repo_target' is set
        if ('repo_target' not in params) or (params['repo_target'] is None):
            raise ValueError("Missing the required parameter `repo_target` when calling `targets_id_put`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'repo_target' in params:
            body_params = params['repo_target']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/{id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_ping_post(self, target, **kwargs):
        """
        Ping validates target.
        This endpoint is for ping validates whether the target is reachable and whether the credential is valid. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_ping_post(target, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PingTarget target: The target object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_ping_post_with_http_info(target, **kwargs)
        else:
            (data) = self.targets_ping_post_with_http_info(target, **kwargs)
            return data

    def targets_ping_post_with_http_info(self, target, **kwargs):
        """
        Ping validates target.
        This endpoint is for ping validates whether the target is reachable and whether the credential is valid. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_ping_post_with_http_info(target, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PingTarget target: The target object. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target' is set
        if ('target' not in params) or (params['target'] is None):
            raise ValueError("Missing the required parameter `target` when calling `targets_ping_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'target' in params:
            body_params = params['target']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets/ping', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def targets_post(self, reptarget, **kwargs):
        """
        Create a new replication target.
        This endpoint is for user to create a new replication target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_post(reptarget, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RepTargetPost reptarget: New created replication target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.targets_post_with_http_info(reptarget, **kwargs)
        else:
            (data) = self.targets_post_with_http_info(reptarget, **kwargs)
            return data

    def targets_post_with_http_info(self, reptarget, **kwargs):
        """
        Create a new replication target.
        This endpoint is for user to create a new replication target. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.targets_post_with_http_info(reptarget, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RepTargetPost reptarget: New created replication target. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reptarget']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method targets_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reptarget' is set
        if ('reptarget' not in params) or (params['reptarget'] is None):
            raise ValueError("Missing the required parameter `reptarget` when calling `targets_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reptarget' in params:
            body_params = params['reptarget']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/targets', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_current_get(self, **kwargs):
        """
        Get current user info.
        This endpoint is to get the current user infomation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_current_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_current_get_with_http_info(**kwargs)
        else:
            (data) = self.users_current_get_with_http_info(**kwargs)
            return data

    def users_current_get_with_http_info(self, **kwargs):
        """
        Get current user info.
        This endpoint is to get the current user infomation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_current_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_current_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/current', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_get(self, **kwargs):
        """
        Get registered users of Harbor.
        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_get_with_http_info(**kwargs)
        else:
            (data) = self.users_get_with_http_info(**kwargs)
            return data

    def users_get_with_http_info(self, **kwargs):
        """
        Get registered users of Harbor.
        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page nubmer, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'email', 'page', 'page_size']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))
        if 'email' in params:
            query_params.append(('email', params['email']))
        if 'page' in params:
            query_params.append(('page', params['page']))
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[User]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_post(self, user, **kwargs):
        """
        Creates a new user account.
        This endpoint is to create a user if the user does not already exist. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_post(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User user: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_post_with_http_info(user, **kwargs)
        else:
            (data) = self.users_post_with_http_info(user, **kwargs)
            return data

    def users_post_with_http_info(self, user, **kwargs):
        """
        Creates a new user account.
        This endpoint is to create a user if the user does not already exist. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_post_with_http_info(user, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User user: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params) or (params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `users_post`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in params:
            body_params = params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_user_id_delete(self, user_id, **kwargs):
        """
        Mark a registered user as be removed.
        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_delete(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_user_id_delete_with_http_info(user_id, **kwargs)
        else:
            (data) = self.users_user_id_delete_with_http_info(user_id, **kwargs)
            return data

    def users_user_id_delete_with_http_info(self, user_id, **kwargs):
        """
        Mark a registered user as be removed.
        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_delete_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_delete`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/{user_id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_user_id_get(self, user_id, **kwargs):
        """
        Get a user's profile.
        Get user's profile with user id. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_get(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_user_id_get_with_http_info(user_id, **kwargs)
        else:
            (data) = self.users_user_id_get_with_http_info(user_id, **kwargs)
            return data

    def users_user_id_get_with_http_info(self, user_id, **kwargs):
        """
        Get a user's profile.
        Get user's profile with user id. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_get_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_get`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/{user_id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_user_id_password_put(self, user_id, password, **kwargs):
        """
        Change the password on a user that already exists.
        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_password_put(user_id, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID. (required)
        :param Password password: Password to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_user_id_password_put_with_http_info(user_id, password, **kwargs)
        else:
            (data) = self.users_user_id_password_put_with_http_info(user_id, password, **kwargs)
            return data

    def users_user_id_password_put_with_http_info(self, user_id, password, **kwargs):
        """
        Change the password on a user that already exists.
        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_password_put_with_http_info(user_id, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID. (required)
        :param Password password: Password to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_password_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_password_put`")
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `users_user_id_password_put`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'password' in params:
            body_params = params['password']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/{user_id}/password', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_user_id_put(self, user_id, profile, **kwargs):
        """
        Update a registered user to change his profile.
        This endpoint let a registered user change his profile. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_put(user_id, profile, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :param UserProfile profile: Only email, realname and comment can be modified. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_user_id_put_with_http_info(user_id, profile, **kwargs)
        else:
            (data) = self.users_user_id_put_with_http_info(user_id, profile, **kwargs)
            return data

    def users_user_id_put_with_http_info(self, user_id, profile, **kwargs):
        """
        Update a registered user to change his profile.
        This endpoint let a registered user change his profile. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_put_with_http_info(user_id, profile, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :param UserProfile profile: Only email, realname and comment can be modified. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'profile']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_put`")
        # verify the required parameter 'profile' is set
        if ('profile' not in params) or (params['profile'] is None):
            raise ValueError("Missing the required parameter `profile` when calling `users_user_id_put`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile' in params:
            body_params = params['profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/{user_id}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def users_user_id_sysadmin_put(self, user_id, has_admin_role, **kwargs):
        """
        Update a registered user to change to be an administrator of Harbor.
        This endpoint let a registered user change to be an administrator of Harbor. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_sysadmin_put(user_id, has_admin_role, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :param HasAdminRole has_admin_role: Toggle a user to admin or not. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, **kwargs)
        else:
            (data) = self.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, **kwargs)
            return data

    def users_user_id_sysadmin_put_with_http_info(self, user_id, has_admin_role, **kwargs):
        """
        Update a registered user to change to be an administrator of Harbor.
        This endpoint let a registered user change to be an administrator of Harbor. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.users_user_id_sysadmin_put_with_http_info(user_id, has_admin_role, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: Registered user ID (required)
        :param HasAdminRole has_admin_role: Toggle a user to admin or not. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'has_admin_role']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_sysadmin_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_sysadmin_put`")
        # verify the required parameter 'has_admin_role' is set
        if ('has_admin_role' not in params) or (params['has_admin_role'] is None):
            raise ValueError("Missing the required parameter `has_admin_role` when calling `users_user_id_sysadmin_put`")


        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'has_admin_role' in params:
            body_params = params['has_admin_role']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/users/{user_id}/sysadmin', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
